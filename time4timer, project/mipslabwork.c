/* mipslabwork.c

   This file written 2015 by F Lundevall
   Updated 2017-04-21 by F Lundevall

   This file should be changed by YOU! So you must
   add comment(s) here with your name(s) and date(s):

   This file modified 2017-04-31 by Ture Teknolog 

   For copyright and licensing, see file COPYING */

#include <stdint.h>   /* Declarations of uint_32 and the like */
#include <pic32mx.h>  /* Declarations of system-specific addresses etc */
#include "mipslab.h"  /* Declatations for these labs */
#define TEMP_SENSOR_ADDR 0x50
int mytime = 0x5957;
int timeoutcount = 0;

char textstring[] = "text, more text, and even more text!";
/* Wait for I2C bus to become idle */
void i2c_idle() {
	while(I2C1CON & 0x1F || I2C1STAT & (1 << 14)); //TRSTAT
}

/* Send one byte on I2C bus, return ack/nack status of transaction */
int i2c_send(uint8_t data) {
	i2c_idle();
	I2C1TRN = data;
	i2c_idle();
	return !(I2C1STAT & (1 << 15)); //ACKSTAT
}


/* Receive one byte from I2C bus */
uint8_t i2c_recv() {
	i2c_idle();
	I2C1CONSET = 1 << 3; //RCEN = 1
	i2c_idle();
	I2C1STATCLR = 1 << 6; //I2COV = 0
	return I2C1RCV;
}

/* Send acknowledge conditon on the bus */
void i2c_ack() {
	i2c_idle();
	I2C1CONCLR = 1 << 5; //ACKDT = 0
	I2C1CONSET = 1 << 4; //ACKEN = 1
}

/* Send not-acknowledge conditon on the bus */
void i2c_nack() {
	i2c_idle();
	I2C1CONSET = 1 << 5; //ACKDT = 1
	I2C1CONSET = 1 << 4; //ACKEN = 1
}

/* Send start conditon on the bus */
void i2c_start() {
	i2c_idle();
	I2C1CONSET = 1 << 0; //SEN
	i2c_idle();
}

/* Send restart conditon on the bus */
void i2c_restart() {
	i2c_idle();
	I2C1CONSET = 1 << 1; //RSEN
	i2c_idle();
}

/* Send stop conditon on the bus */
void i2c_stop() {
	i2c_idle();
	I2C1CONSET = 1 << 2; //PEN
	i2c_idle();
}

/* Convert 8.8 bit fixed point to string representation*/
char *int_to_string(uint16_t num, char *buf) {
	uint32_t n;
	char *tmp;
	
	
	buf += 4;
	n = num;
	tmp = buf;
	do {
		*--tmp = (n  % 10) + '0';
		n /= 10;
	} while(n);
	
	*--tmp = ' ';
	
	n = num;
	
	*buf = 0;
	
	return tmp;
}

uint32_t strlen(char *str) {
	uint32_t n = 0;
	while(*str++)
		n++;
	return n;
}

/* Interrupt Service Routine */
void user_isr( void )
{
  return;
}
/* Lab-specific initialization goes here */
void labinit( void )
{
  //TRISE &= ~0xff;
    volatile int* trise = (volatile int*) 0xbf886100;
	*trise &= 0xffffff00;
	TRISF |= 0x00000002;
	
	
	TRISD |= 0x00000fe0;
	
	T2CON = 0x70;
	PR2 = 50000;
	TMR2 = 0;
	T2CONSET = 0x8050;
	
	uint16_t temp;

	/* Set up peripheral bus clock */
	OSCCON &= ~0x180000;
	OSCCON |= 0x080000;
	
	/* Set up output pins */
	AD1PCFG = 0xFFFF;
	ODCE = 0x0;
	TRISECLR = 0xFF;
	PORTE = 0x0;
	
	/* Output pins for display signals */
	PORTF = 0xFFFF;
	PORTG = (1 << 9);
	ODCF = 0x0;
	ODCG = 0x0;
	TRISFCLR = 0x70;
	TRISGCLR = 0x200;
	
	/* Set up input pins */
	TRISDSET = (1 << 8);
	TRISFSET = (1 << 1);
	
	/* Set up SPI as master */
	SPI2CON = 0;
	SPI2BRG = 4;
	
	/* Clear SPIROV*/
	SPI2STATCLR &= ~0x40;
	/* Set CKP = 1, MSTEN = 1; */
        SPI2CON |= 0x60;
	
	/* Turn on SPI */
	SPI2CONSET = 0x8000;
	
	/* Set up i2c */
	I2C1CON = 0x0;
	/* I2C Baud rate should be less than 400 kHz, is generated by dividing
	the 40 MHz peripheral bus clock down */
	I2C1BRG = 0x0C2;
	I2C1STAT = 0x0;
	I2C1CONSET = 1 << 13; //SIDL = 1
	I2C1CONSET = 1 << 15; // ON = 1
	temp = I2C1RCV; //Clear receive buffer
	
	/* Set up input pins */
	TRISDSET = (1 << 8);
	TRISFSET = (1 << 1);
	
    return;
}
int num = 567; // global variable for random function below, incremented while waiting for button press

int rand(int n){
	return (num%n) + 1;
}

uint8_t readEEPROM(uint8_t address){
	do {
		i2c_start();
	} while(!i2c_send(TEMP_SENSOR_ADDR << 1));
	i2c_send(0x00);
	/* Set the config register to 0 */
	i2c_send(address);
	do {
		i2c_start();
	} while(!i2c_send((TEMP_SENSOR_ADDR << 1)|1));
		
	uint8_t temp = i2c_recv();
		
	i2c_nack();
	i2c_stop();
	return temp;
}
void writeEEPROM(int score, uint8_t address){
	do {
		i2c_start();
	} while(!i2c_send(TEMP_SENSOR_ADDR << 1));
	i2c_send(0x00);
	i2c_send(address);
	i2c_send(score);
	i2c_stop();
}
// global variables
int count = 0; // counts number of instructions
short sequence[96]; // array for storing the instructions
char level = 0; // updated depending on level, 0, 1 or 2
int idiot; // value for the idiot level where we have only one button

//adds instructions, one number only for idiot level, otherwise random
void add_instruction(){
	if(level == 0){
		sequence[count] = idiot;
	}
	else{
		sequence[count] = rand(4);
	}
	count = count + 1;
}

int increaseSpeed = 0; // global variable that increases the speed in not for losers level

// displays the instructions one by one, if not for losers level also faster and faster
void display_instructions(){
	int i=0;
	int y;
	if((level == 2) && (increaseSpeed < 30)){
		increaseSpeed = increaseSpeed + 5;
	}
	while( i < count ){
		// y moves the arrow downwards from Y = 0 -> 32, all the way across the screen
		for(y = 0; y <33; y++){
			display_update();
			display_image((4 - sequence[i])*32, y, icon);
			delay(30 - increaseSpeed);

		}
		i = i + 1;	
	}
}
char correct = 1; //global variable that checks whether the input matches the instruction or not

void check_input(){
	char buf4[32];
	int i = 0;
	while( i < count){
		volatile int check_btns = getbtns(); // so that we check for changes every time
		// while no buttons have been pressed, increments random variable
		while(check_btns == 0){
			num = num + 1;
			check_btns = getbtns();
		}
		volatile int check_btns2 = getbtns();
		while(check_btns2){
			num = num + 1;
			check_btns2 = getbtns();
		}
		//delay(300); // delay required, otherwise the input is checked too quickly
		if( (check_btns & 0x1) && (sequence[i] == 1)){
		}
		else if( ((check_btns >> 1) & 0x1) && (sequence[i] == 2)){
		}
		else if( ((check_btns >> 2) & 0x1) && (sequence[i] == 3)){
		}
		else if( ((check_btns >> 3) & 0x1) && (sequence[i] == 4)){
		}
		else {
			//display_string(0, "   GAME OVER");
			char* score;
			score = int_to_string(count - 1, buf4);
			display_string(1, " GAME OVER");
			display_string(2, score);

			display_update();
			correct = 0;
			delay(1000);
			break;
		}
		display_string(0, "");
		display_update();
		i = i + 1;
		check_btns = 0;
	}
}	

/* This function is called repetitively from the main program */
void labwork( void )
{ 	
	char buf[32], buf2[32], buf3[32];
	//fetching high score
	uint8_t first = readEEPROM(1);
	uint8_t second = readEEPROM(2);
	uint8_t third = readEEPROM(3);
	int i;
	for(i = 0; i < 96; i++){
			sequence[i] = 0;
	}
	char option = 1;
	volatile int btns = getbtns(); 
 	// while the first button "select" is not pressed
	while((btns & 0x1) == 0){
		btns = getbtns();
		num = num + 1;
		// if button 2 or 3 are pressed, increment option
		if((btns >> 1) & 0x3){ 
			option = option + 1;
			delay(250);
		}
		// option is either 1 or 0 depending on if it's even or not
		option = option % 2;
		// uneven - choose Start, else even - choose High score
		if(option == 1){
			display_string(0, "MENU");
			display_string(2,"oStart");
			display_string(3,"High score");
		}
		else{
			display_string(0, "MENU");
			display_string(2," Start");
			display_string(3,"oHigh score");
		}
		display_update();
	}
	delay(250);
	
 	// "clean" the screen 
	display_string(0,"");
	display_string(1,"");
	display_string(2,"");
	display_string(3,"");
	display_update();
	
	idiot = rand(4);
	
 	if(option == 1){
		btns = getbtns();
		// while the first button "select" is not pressed
		while((btns & 0x1) == 0){
			btns = getbtns();
			// if the second button is pressed, go down
			if((btns >> 1) & 0x1){
				level = level + 1;
				delay(250);
			}
			//if the third button is pressed, go up
			if((btns >> 2) & 0x1){
				if(level > 0){
					level = level - 1;
				}
				else{
					level = 2;
				}
				delay(250);
			}
			// level can be wither 0=idiot, 1=normal or 2=not for losers
			level = level % 3;
			if(level == 0){
				display_string(0, "LEVEL:");
				display_string(1,"oIdiot ");
				display_string(2,"Normal");
				display_string(3,"Not for Losers");
				display_update();
			}
			else if(level == 1){
				display_string(0, "LEVEL:");
				display_string(1,"Idiot");
				display_string(2,"oNormal");
				display_string(3,"Not for Losers");
				display_update();
			}
			else{
				display_string(0, "LEVEL:");
				display_string(1,"Idiot");
				display_string(2,"Normal");
				display_string(3,"oNot for Losers");
				display_update();
			}
			display_update();
		}
		display_string(0,"");
		display_string(1,"");
		display_string(2,"");
		display_string(3,"");
		display_update();
		// while no wrong buttons have been pressed
		while(correct){
			display_update();
			delay(1000);
			add_instruction();
			// adds another instruction if highest level
			if( level == 2){
				num = (num*3+1)*7;
				add_instruction();
			}
			display_instructions();
			check_input();
			num = num + 1; // increments random variable
		}
		
		if( level == 1){
			if(count - 1 > first){
				writeEEPROM(second, 3);
				writeEEPROM(first, 2);
				writeEEPROM(count - 1, 1);
			}
			else if(count - 1 > second){
				writeEEPROM(second, 3);
				writeEEPROM(count - 1, 2);
			}
			else if(count - 1 > third){
				writeEEPROM(count - 1, 3);
			}
		}
		// resetting the global variables
		level = 0;
		option = 1;
		correct = 1;
		count = 0;
		increaseSpeed = 0;
		
		
		display_string(0,"");
		display_string(1,"");
		display_string(2,"");
		display_string(3,"");
		display_update();
		
	}
	else{
		while(!((btns >> 3) & 0x1)){
			display_string(0, "  HIGH SCORE");

			char *one, *two, *three;
			one = int_to_string(first, buf);
			two = int_to_string(second, buf2);
			three = int_to_string(third, buf3);
			display_string(1, one);
			display_string(2, two);
			display_string(3, three);
			display_update();
			btns = getbtns();
		}
	}
}
