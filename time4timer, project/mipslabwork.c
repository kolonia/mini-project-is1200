/* mipslabwork.c

   This file written 2015 by F Lundevall
   Updated 2017-04-21 by F Lundevall

   This file should be changed by YOU! So you must
   add comment(s) here with your name(s) and date(s):

   This file modified 2017-04-31 by Ture Teknolog 

   For copyright and licensing, see file COPYING */
   
 /* The I2C functions are borrowed from code written by
    Axel Isaksson */  

#include <stdint.h>   /* Declarations of uint_32 and the like */
#include <pic32mx.h>  /* Declarations of system-specific addresses etc */
#include "mipslab.h"  /* Declatations for these labs */
#define EEPROM_ADDR 0x50

/* Interrupt Service Routine */
void user_isr( void )
{
  return;
}

/* Wait for I2C bus to become idle, Copyright (c) 2015, Axel Isaksson*/
void i2c_idle() {
	while(I2C1CON & 0x1F || I2C1STAT & (1 << 14)); //TRSTAT
}

/* Send one byte on I2C bus, return ack/nack status of transaction, Copyright (c) 2015, Axel Isaksson*/
int i2c_send(uint8_t data) {
	i2c_idle();
	I2C1TRN = data;
	i2c_idle();
	return !(I2C1STAT & (1 << 15)); //ACKSTAT
}

/* Receive one byte from I2C bus, Copyright (c) 2015, Axel Isaksson*/
uint8_t i2c_recv() {
	i2c_idle();
	I2C1CONSET = 1 << 3; //RCEN = 1
	i2c_idle();
	I2C1STATCLR = 1 << 6; //I2COV = 0
	return I2C1RCV;
}

/* Send acknowledge conditon on the bus, Copyright (c) 2015, Axel Isaksson*/
void i2c_ack() {
	i2c_idle();
	I2C1CONCLR = 1 << 5; //ACKDT = 0
	I2C1CONSET = 1 << 4; //ACKEN = 1
}

/* Send not-acknowledge conditon on the bus, Copyright (c) 2015, Axel Isaksson*/
void i2c_nack() {
	i2c_idle();
	I2C1CONSET = 1 << 5; //ACKDT = 1
	I2C1CONSET = 1 << 4; //ACKEN = 1
}

/* Send start conditon on the bus, Copyright (c) 2015, Axel Isaksson*/
void i2c_start() {
	i2c_idle();
	I2C1CONSET = 1 << 0; //SEN
	i2c_idle();
}

/* Send restart conditon on the bus, Copyright (c) 2015, Axel Isaksson*/
void i2c_restart() {
	i2c_idle();
	I2C1CONSET = 1 << 1; //RSEN
	i2c_idle();
}

/* Send stop conditon on the bus, Copyright (c) 2015, Axel Isaksson*/
void i2c_stop() {
	i2c_idle();
	I2C1CONSET = 1 << 2; //PEN
	i2c_idle();
}

/* Convert numbers to strings
   based on function fixed_to_string
   by Copyright (c) 2015, Axel Isaksson
   modified by us*/
char *int_to_string(uint16_t num, char *buf) {
	uint32_t n;
	char *tmp;
	buf += 4;
	n = num;
	tmp = buf;
	
	do {
		*--tmp = (n  % 10) + '0';
		n /= 10;
	} while(n);
	
	*--tmp = ' ';
	n = num;
	*buf = 0;
	
	return tmp;
}


/* Lab-specific initialization goes here, borrowed from lab files */
void labinit( void )
{
  //TRISE &= ~0xff;
    volatile int* trise = (volatile int*) 0xbf886100;
	*trise &= 0xffffff00;
	TRISF |= 0x00000002;
	
	
	TRISD |= 0x00000fe0;
	
	T2CON = 0x70;
	PR2 = 50000;
	TMR2 = 0;
	T2CONSET = 0x8050;
	
	uint16_t temp;

	/* Set up peripheral bus clock */
	OSCCON &= ~0x180000;
	OSCCON |= 0x080000;
	
	/* Set up output pins */
	AD1PCFG = 0xFFFF;
	ODCE = 0x0;
	TRISECLR = 0xFF;
	PORTE = 0x0;
	
	/* Output pins for display signals */
	PORTF = 0xFFFF;
	PORTG = (1 << 9);
	ODCF = 0x0;
	ODCG = 0x0;
	TRISFCLR = 0x70;
	TRISGCLR = 0x200;
	
	/* Set up input pins */
	TRISDSET = (1 << 8);
	TRISFSET = (1 << 1);
	
	/* Set up SPI as master */
	SPI2CON = 0;
	SPI2BRG = 4;
	
	/* Clear SPIROV*/
	SPI2STATCLR &= ~0x40;
	/* Set CKP = 1, MSTEN = 1; */
        SPI2CON |= 0x60;
	
	/* Turn on SPI */
	SPI2CONSET = 0x8000;
	
	/* Set up i2c */
	I2C1CON = 0x0;
	/* I2C Baud rate should be less than 400 kHz, is generated by dividing
	the 40 MHz peripheral bus clock down */
	I2C1BRG = 0x0C2;
	I2C1STAT = 0x0;
	I2C1CONSET = 1 << 13; //SIDL = 1
	I2C1CONSET = 1 << 15; // ON = 1
	temp = I2C1RCV; //Clear receive buffer
	
	/* Set up input pins */
	TRISDSET = (1 << 8);
	TRISFSET = (1 << 1);
	
    return;
}

/* random function written by us*/
int num = 567; // global variable for random function below, incremented while waiting for button press
int rand(int n){
	return (num%n) + 1;
}

/* readEEPROM (random read) and writeEEPROM are written by us
   with functions borrowed from Copyright (c) 2015, Axel Isaksson*/
uint8_t readEEPROM(uint8_t address){
	do {
		i2c_start();
	} while(!i2c_send(EEPROM_ADDR << 1));
	i2c_send(0x00);
	/* Set the config register to 0 */
	i2c_send(address);
	do {
		i2c_start();
	} while(!i2c_send((EEPROM_ADDR << 1)|1));
		
	uint8_t temp = i2c_recv();
		
	i2c_nack();
	i2c_stop();
	return temp;
}
void writeEEPROM(int score, uint8_t address){
	do {
		i2c_start();
	} while(!i2c_send(EEPROM_ADDR << 1));
	i2c_send(0x00);
	i2c_send(address);
	i2c_send(score);
	i2c_stop();
}
// global variables
int count = 0; // counts number of instructions
short sequence[96]; // array for storing the instructions
char level = 0; // updated depending on level, 0, 1 or 2
int idiot; // value for the idiot level where we have only one button
int restart = 0; // value for restart or back to menu
char correct = 1; //global variable that checks whether the input matches the instruction or not
int increaseSpeed = 0; // global variable that increases the speed in not for losers level

//adds instructions, one number only for idiot level, otherwise random
void add_instruction(){
	if(level == 0){
		sequence[count] = idiot;
	}
	else{
		if( level == 2){
			sequence[count] = rand(4);
			count = count + 1;
			num = (num*3+1)*7;
			delay(30);
		}
		sequence[count] = rand(4);
	}
	count = count + 1;
}

// displays the instructions one by one, if not for losers level also faster and faster
void display_instructions(){
	int i=0;
	int y;
	if((level == 2) && (increaseSpeed < 20)){
		increaseSpeed = increaseSpeed + 5;
	}
	while( i < count ){
		// y moves the arrow downwards from Y = 0 -> 32, all the way across the screen
		for(y = 0; y <33; y++){
			display_update();
			display_image((4 - sequence[i])*32, y, 12, 32, icon);
			delay(30 - increaseSpeed);

		}
		i = i + 1;	
	}
}

// function written by us to check that the input matches the instruction sequence
void check_input(){
	char buf4[32];
	int i = 0;
	while( i < count){
		volatile int check_btns = getbtns(); // so that we check for changes every time
		// while no buttons have been pressed, increments random variable
		while(check_btns == 0){
			num = num + 1;
			check_btns = getbtns();
		}
		volatile int check_btns2 = getbtns();
		while(check_btns2){
			num = num + 1;
			check_btns2 = getbtns();
		}
		//delay(300); // delay required, otherwise the input is checked too quickly
		if( (check_btns & 0x1) && (sequence[i] == 1)){
		}
		else if( ((check_btns >> 1) & 0x1) && (sequence[i] == 2)){
		}
		else if( ((check_btns >> 2) & 0x1) && (sequence[i] == 3)){
		}
		else if( ((check_btns >> 3) & 0x1) && (sequence[i] == 4)){
		}
		else {
			char* score;
			
			score = int_to_string(count - 1, buf4);
			display_string(1, " GAME OVER");
			display_string(2, score);
			display_update();
			
			correct = 0;
			delay(1000);
			break;
		}
		display_string(0, "");
		display_update();
		i = i + 1;
		check_btns = 0;
	}
}	

/* This function is called repetitively from the main program */
void labwork( void )
{ 	
	char buf[32], buf2[32], buf3[32];
	//fetching high score
	uint8_t first = readEEPROM(1);
	uint8_t second = readEEPROM(2);
	uint8_t third = readEEPROM(3);
	int i;
	for(i = 0; i < 96; i++){
			sequence[i] = 0;
	}
	char option = 1;
	volatile int btns = getbtns(); 
	if(restart == 0){
 	// while the first button "select" is not pressed
		while((btns & 0x1) == 0){
			btns = getbtns();
			num = num + 1;
			// if button 2 or 3 are pressed, increment option
			if((btns >> 1) & 0x3){ 
				option = option + 1;
				delay(250);
			}
			// option is either 1 or 0 depending on if it's even or not
			option = option % 2;
			// uneven - choose Start, else even - choose High score
			if(option == 1){
				display_string(0, "MENU");
				display_string(1,"");
				display_string(2,"oStart");
				display_string(3,"High score");
			}
			else{
				display_string(0, "MENU");
				display_string(2," Start");
				display_string(3,"oHigh score");
			}
			display_update();
		}
		delay(250);
	}
	
 	// "clean" the screen 
	display_string(0,"");
	display_string(1,"");
	display_string(2,"");
	display_string(3,"");
	display_update();
	
	idiot = rand(4);
	
 	if(option == 1){
		if(restart == 0){
			btns = getbtns();
			// while the first button "select" is not pressed
			while((btns & 0x1) == 0){
				btns = getbtns();
				// if the second button is pressed, go down
				if((btns >> 1) & 0x1){
					level = level + 1;
					delay(250);
				}
				//if the third button is pressed, go up
				if((btns >> 2) & 0x1){
					if(level > 0){
						level = level - 1;
					}
					else{
						level = 2;
					}
					delay(250);
				}
				// level can be wither 0=idiot, 1=normal or 2=not for losers
				level = level % 3;
				if(level == 0){
					display_string(0, "LEVEL:");
					display_string(1,"oIdiot ");
					display_string(2,"Normal");
					display_string(3,"Not for Losers");
					display_update();
				}
				else if(level == 1){
					display_string(0, "LEVEL:");
					display_string(1,"Idiot");
					display_string(2,"oNormal");
					display_string(3,"Not for Losers");
					display_update();
				}
				else{
					display_string(0, "LEVEL:");
					display_string(1,"Idiot");
					display_string(2,"Normal");
					display_string(3,"oNot for Losers");
					display_update();
				}
				display_update();
			}
		}
		display_string(0,"");
		display_string(1,"");
		display_string(2,"");
		display_string(3,"");
		display_update();
		// while no wrong buttons have been pressed
		while(correct){
			display_update();
			delay(1000);
			add_instruction();
			display_instructions();
			check_input();
			num = num + 1; // increments random variable
		}
		
		// save high score to EEPROM
		if( level == 1){
			
			if(count - 1 > first){
				writeEEPROM(second, 3);
				writeEEPROM(first, 2);
				writeEEPROM(count - 1, 1);
			}
			else if(count - 1 > second){
				writeEEPROM(second, 3);
				writeEEPROM(count - 1, 2);
			}
			else if(count - 1 > third){
				writeEEPROM(count - 1, 3);
			}
		}		
		
		display_string(0,"");
		display_string(1,"");
		display_string(2,"");
		display_string(3,"");
		display_update();
		
		int x = 60;
		int y = 28;
		display_image(x, y, 4, 8, icon2);
		display_string(0, "MENU<<|>>RESTART");
		display_update();
		volatile int get_btns = getbtns();
		while(!(y < 9)){
			get_btns = getbtns();
			if(get_btns & 0x1){
				x = x + 1;
			}
			else if((get_btns >> 1)& 0x1){
				y = y + 1;
			}
			else if((get_btns >> 2)& 0x1){
				y = y - 1;
			}
			else if((get_btns >> 3)& 0x1){
				x = x - 1;
			}
			display_update();
			display_image(x, y, 4, 8, icon2);
			display_string(0, "MENU<<|>>RESTART");
			
			delay(75);
		}
		if(( x > 48 && y < 9)){
			restart = 1;
		}
		else{
			restart = 0;
			level = 0;
		}
		// resetting the global variables
		option = 1;
		correct = 1;
		count = 0;
		increaseSpeed = 0;
		
		
	}
	else{
		while(!((btns >> 3) & 0x1)){
			display_string(0, "  HIGH SCORE");

			char *one, *two, *three;
			one = int_to_string(first, buf);
			two = int_to_string(second, buf2);
			three = int_to_string(third, buf3);
			display_string(1, one);
			display_string(2, two);
			display_string(3, three);
			display_update();
			btns = getbtns();
		}
	}
}
